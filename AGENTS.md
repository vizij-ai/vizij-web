# Vizij‑Web AGENTS.md – Unified guidance for Gemini, Claude and Codex

Welcome! This file guides AI coding agents—Gemini CLI, Claude Code and OpenAI Codex—on how to work effectively within the `vizij-web` monorepo. It consolidates project context, commands, coding conventions and collaboration practices. Keep this document up to date as new packages or workflows are introduced.

## Project overview and structure

`vizij-web` hosts the web bindings and demo site for the Vizij engine. The repository uses npm workspaces (or pnpm) to organise packages. Known entries include:

- **packages/@vizij/animation-react** – React hooks and components that wrap the `@vizij/animation-wasm` module. Built outputs live in `dist/`. Dependencies include `@vizij/animation-wasm` and `react`.
- **packages/@vizij/node-graph-react** – React bindings for the node‑graph engine with outputs in `dist/`. Depends on `@vizij/node-graph-wasm` and `react`.
- **apps/website** – A Vite + React TypeScript demo site showcasing the animation and node‑graph packages. Note: current setup requires manually copying a wasm module into `apps/vizij-site/animation-player/pkg` for the player to work.
- **Generated wasm packages** – `@vizij/animation-wasm` and `@vizij/node-graph-wasm` are generated from the Rust repository `vizij-rs` and published separately on npm.

Additional packages can be added as the project expands; list them here when introduced.

## Key commands and workflows

Use these commands from the repository root unless noted otherwise. Adjust for `pnpm` if the project uses pnpm workspaces.

### Installing and building

- **Install dependencies:**

  ```bash
  npm install    # or pnpm install
  ```

- **Build all packages:**

  ```bash
  npm run build
  ```

  This invokes the `build` script of each package (usually `tsc`).

- **Build a specific package:**

  ```bash
  npm run build --workspace=@vizij/animation-react
  ```

- **Run the demo site:**

  ```bash
  cd apps/website
  npm run dev     # Start Vite dev server
  npm run build   # Build production site
  npm run preview # Preview production build (if configured)
  ```

- **Publish a package:**
  Always run a dry‑run first. Execute from the package directory:

  ```bash
  cd packages/@vizij/animation-react
  npm publish --access public --provenance --dry-run
  # remove --dry-run to publish
  ```

### Testing, linting and type‑checking

- **Run tests (if configured):**

  ```bash
  npm test
  ```

- **Lint code:**

  ```bash
  npm run lint
  ```

- **Type‑check:** If a dedicated script exists:

  ```bash
  npm run type-check
  ```

  Otherwise, run `tsc -p tsconfig.json` in the relevant package to ensure TypeScript types are correct.

### Commit and pull request guidelines

1. **Use semantic versioning** – Major for breaking public API changes, minor for new features, patch for bug fixes. Update `package.json` versions and adjust dependency ranges accordingly (e.g. \`"@vizij/animation-wasm": "^0.2.0").
2. **Write conventional commit messages** – Prefix messages with `feat:`, `fix:`, `refactor:`, `chore:` etc., and mention the affected package(s) where appropriate.
3. **Create small, focused pull requests** – Each PR should build and test successfully, and should address a single task. Provide clear descriptions and link related issues.
4. **Ensure programmatic checks pass** – Always run `npm install`, `npm run build`, `npm run lint` and `npm test` (if tests exist) before submitting a PR. All commands must succeed.
5. **Include updated builds** – Ensure that the `dist/` directory is regenerated after making changes. Do not commit compiled files unnecessarily; commit them only when required by publishing workflows or if CI does not build them.

## Coding conventions and implementation guidelines

### TypeScript and React

- **Strict TypeScript** – Enable `strict` and other recommended compiler options. Use type annotations and generics to express intent.
- **Functional components and hooks** – Write React components as pure functions and use hooks (`useEffect`, `useMemo`, custom hooks) for state and side effects. Avoid class components.
- **Component structure** – Organise code under `src/components/`, `src/hooks/`, `src/utils/`, and re-export public APIs via `src/index.ts`.
- **Named exports** – Use named exports for hooks and components to improve tree‑shaking and clarity.
- **Styling** – For library packages, avoid global styles; rely on CSS‑in‑JS or let consuming applications provide styling. For the demo site, follow Vite and Tailwind (if used) conventions and keep styles scoped.
- **Documentation** – Provide JSDoc comments for public functions, hooks and components. Include usage examples where appropriate.

### WebAssembly integration

- **Async loading** – Load wasm modules asynchronously using the JS glue generated by `wasm-bindgen`. Use dynamic import syntax and pass the `.wasm` file via `new URL()` to ensure bundlers like Vite can locate the asset.
- **Loading states** – Components that depend on wasm should handle loading states and errors gracefully. Expose helper hooks for initialising the wasm modules.
- **Avoid global side effects** – Do not import and initialise wasm modules at the top level of a module; wrap them in hooks or functions so they load only when needed.

## Testing and quality assurance

- **Unit tests** – Use a JavaScript testing framework (Jest or Vitest) combined with React Testing Library. Place tests alongside components (e.g. `ComponentName.test.tsx`) or under a `tests/` directory.
- **Integration tests** – For complex interactions (e.g. between animation and the demo site), write integration tests that render components in a simulated environment.
- **Wasm testing** – While most wasm logic is tested in the Rust repository, you can write high‑level tests in the React layer to ensure wasm functions integrate correctly.
- **Linting and formatting** – Configure ESLint and Prettier. Enforce consistent coding styles and catch potential issues early.
- **CI** – CI should run build, lint, type‑check and tests. It should also publish packages when tags/branches indicate a release.

## Developer environment and setup

- Use Node.js 18+ and npm 9+ (or pnpm 8+ if adopting pnpm).
- Install the latest TypeScript compiler and the `@types/react` package for type definitions.
- Configure your editor (e.g. VS Code) with ESLint, Prettier and the TypeScript language server.
- For the demo site, install Vite and appropriate plugins (such as `@vitejs/plugin-react`) and configure them in `vite.config.ts`.

## Repository etiquette and additional notes

- **Dist folder management** – Do not commit compiled `dist/` files unless they are required for publishing. Use `.gitignore` to avoid accidentally committing them. Regenerate `dist/` before publishing a package.
- **Synchronise versions with Rust crates** – After releasing new versions of the Rust wasm crates (`vizij-animation-wasm` and `vizij-graph-wasm`), bump the versions of their corresponding React packages and update dependency ranges. Publish the wasm packages first, then the React packages.
- **Manual wasm copying** – Currently the demo site requires manually copying wasm modules into `apps/vizij-site/animation-player/pkg`. Document this step in PRs affecting the player and consider automating it via build scripts.
- **Adding new packages** – When adding a new package or entry point, update this AGENTS.md to describe its purpose, location and build/test commands.
- **Major changes** – For significant design changes, write a design doc under a `docs/` directory and gather feedback before implementation.
